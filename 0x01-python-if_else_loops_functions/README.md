# Documentation du Projet : "Positive anything is better than negative nothing"

## Introduction

Ce programme Python génère et attribue un nombre aléatoire (positif ou négatif) à la variable `number` à chaque exécution. L'objectif du programme est d'afficher si le nombre stocké dans la variable `number` est positif, nul ou négatif.

## Prérequis

Le programme utilise le module `random` de Python pour générer des nombres aléatoires et utilise la fonction `randint` pour attribuer un nombre entier aléatoire à la variable `number`. Aucune connaissance préalable des détails de ces modules n'est nécessaire pour comprendre ou exécuter le programme.

## Utilisation

### Téléchargement du code source

Le code source du programme est disponible dans le [répertoire GitHub](lien_vers_le_referentiel) suivant :

- **Référentiel GitHub :** [alx-higher_level_programming](lien_vers_le_referentiel)
- **Répertoire :** 0x01-python-if_else_loops_functions
- **Fichier :** `0-positive_or_negative.py`

Pour télécharger le code source, vous pouvez cloner le référentiel en utilisant la commande suivante dans votre terminal :

```bash
git clone [lien_vers_le_referentiel]
```

### Exécution du programme

Une fois que le code source a été téléchargé, vous pouvez exécuter le programme en utilisant la commande suivante dans votre terminal :

```bash
./0-positive_or_negative.py
```

À chaque exécution, la variable `number` sera mise à jour avec un nouveau nombre aléatoire, et le programme affichera si le nombre est positif, nul ou négatif.

### Exemple de sortie

Voici des exemples de sortie du programme :

```bash
-4 is negative
0 is zero
-3 is negative
-10 is negative
10 is positive
-5 is negative
6 is positive
7 is positive
5 is positive
```

La sortie affiche le nombre généré, suivi de l'indication s'il est positif, nul ou négatif.

## Conclusion

Ce programme simple démontre l'utilisation de nombres aléatoires en Python et offre une introduction à la structure conditionnelle pour déterminer la positivité ou la négativité d'un nombre. Son exécution répétée génère des résultats différents à chaque fois.
